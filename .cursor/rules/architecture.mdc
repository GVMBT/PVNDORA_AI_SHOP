---
alwaysApply: true
---
# Project Architecture & Implementation Rules

You are an expert Senior Python Backend Developer specializing in Telegram Bots, Vercel Serverless, and AI Agents.

## 0. Mode Detection & Change Authorization

**CRITICAL RULE:** NEVER make code changes without explicit user authorization.

### Read-Only Mode Indicators
When user says: "исследование", "проверь", "изучи", "посмотри", "исследуй", "research", "investigate", "check", "examine", "analyze", "why", "why is", "what's wrong"

**Required Actions:**
1. Use ONLY read-only tools (`read_file`, `grep`, `codebase_search`, `list_dir`)
2. Provide detailed analysis
3. Identify root causes
4. Suggest solutions
5. DO NOT implement changes

### Write Mode Indicators
When user says: "сделай", "исправь", "реализуй", "добавь", "do", "fix", "implement", "add", "create", "update"

**Required Actions:**
1. First: Complete investigation (if not done)
2. Then: Make changes
3. Follow all checklists

**Enforcement:**
- If unsure about mode → Default to read-only
- If user says "но не меняй" or "don't change" → Read-only ONLY
- Always ask for confirmation before destructive operations

## 1. Technology Stack

- **Runtime:** Python 3.12 (Vercel Serverless)
- **Framework:** FastAPI 0.115+ (single Serverless Function entry point)
- **AI Core:** OpenRouter API + LangGraph (Model: google/gemini-3-flash-preview via OpenAI-compatible endpoint)
- **AI Libraries:** `langchain_openai.ChatOpenAI`, `langgraph.prebuilt.create_react_agent`
- **Database:** Supabase (PostgreSQL) via supabase-py. **NO ORM** (SQLAlchemy/Django forbidden)
- **Async Messaging:** Upstash QStash (REQUIRED for critical long-running tasks)
- **State/Cache:** Upstash Redis (via HTTP REST API)

## 2. Critical Architectural Patterns

### A. Monolithic Entry Point

**Constraint:** Vercel has limit of 12 functions per deployment on Hobby plans.

**Rule:** ALL API routes must be routed through single entry point: `api/index.py`

### B. Asynchronous Reliability

**Rule:** Use **Upstash QStash** for all critical async operations (payments, delivery, notifications).

**Pattern:** Webhook → Validate → Push to QStash → Return 200 OK → QStash calls worker endpoint

**Forbidden:** DO NOT use Supabase Triggers (pg_net) for business logic. Use QStash instead.

**Best-Effort:** Use `BackgroundTasks` only for non-critical operations (AI responses, logging).

### C. Payment Flow

**Rule:** Use WebApp "Gasket" for external payments (1Plat).

**Flow:** AI detects purchase → Generate order UUID → Bot sends payment button → WebApp redirects → Webhook updates DB → Deliver goods

### D. Localization

**Rule:** Static bot configuration in `bot_setup/bot_info.json`. Apply via `scripts/setup_bot.py` locally. **DO NOT** call `setMyDescription` in runtime code.

**Runtime:** Extract `user_language` from `update.message.from_user.language_code` → Pass to System Prompt.

## 3. Implementation Guidelines

### OpenRouter + LangGraph Integration

- Use **OpenRouter API** via `langchain_openai.ChatOpenAI` with `openai_api_base="https://openrouter.ai/api/v1"`
- Use **LangGraph** `create_react_agent` for ReAct pattern (reasoning + acting)
- Default model: `google/gemini-3-flash-preview` (can switch to `google/gemini-2.5-flash` or other OpenRouter models)
- Environment variable: `OPENROUTER_API_KEY` (required). Fallback to `GEMINI_API_KEY` for backward compatibility
- Inject product catalog data via `format_product_catalog()` into System Prompt (don't query DB for static products in tools)
- Function Calling: Use LangGraph tools. Only `check_product_availability` for validation. Reserve/create operations handled by backend
- Agent responses: Parse LangGraph result into `AgentResponse` dataclass (content, tool_calls, action, product_id, etc.)
- Chat history: Load from database and inject into System Prompt (last 12-20 messages)
- Retry logic: Built-in retry (2 attempts) for agent failures

### Real-time Validation

**Rule:** Before any purchase action, validate availability via `available_stock_with_discounts` View or AI Function Calling.

### Transactional Integrity

**Rule:** All transactional operations (reservation, purchase) must use PostgreSQL RPC functions for atomicity.

### QStash Workers

**Rule:** All critical operations via QStash Workers. Endpoints must verify request signature.

**Endpoints:**
- `POST /api/workers/deliver-goods`
- `POST /api/workers/update-leaderboard`
- `POST /api/workers/notify-supplier`
- `POST /api/workers/update-referral-bonus`

### Environment Variables (Required)

- `TELEGRAM_TOKEN`, `TELEGRAM_WEBHOOK_URL`
- `SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY`
- `OPENROUTER_API_KEY` (required for AI agent). Fallback: `GEMINI_API_KEY` (legacy)
- `QSTASH_URL`, `QSTASH_TOKEN`, `QSTASH_CURRENT_SIGNING_KEY`, `QSTASH_NEXT_SIGNING_KEY`
- `UPSTASH_REDIS_URL`, `UPSTASH_REDIS_TOKEN`
- `ONEPLAT_SHOP_ID`, `ONEPLAT_SECRET_KEY` (required)
- `WEBAPP_URL`, `BASE_URL` (for QStash worker endpoints)

## 4. Code Style

- **Type Hints:** Strict typing required
- **Async:** Use `async/await` everywhere. `supabase-py` methods must be awaited
- **Validation:** Use `pydantic` for all data ingress (Telegram Updates, Webhook Payloads)
- **Error Handling:** Use `tenacity` for retry logic on Pydantic validation errors

## 5. Build & Testing

**Rule:** ALWAYS verify Vercel build status after pushing changes.

**Before pushing:**
- [ ] `npm run build` passes locally
- [ ] `ruff check .` passes for Python files
- [ ] All imported components exist
- [ ] No circular imports

**After implementing UI features:**
- [ ] Test visually (button placement, styling, responsive)
- [ ] Test functionally (handlers, API calls, error states)
- [ ] Verify consistency across pages

## 6. Key Principles

1. **Always return fast** - BackgroundTasks for UX, QStash for critical
2. **Guaranteed delivery** - QStash for all transactional operations
3. **Real-time validation** - Validate inventory before critical actions
4. **Optimize with SQL** - Calculate discounts, aggregations in database (SQL Views)
5. **RAG for search** - Use vector search (pgvector via Supabase) for product discovery. Embeddings via OpenRouter API
6. **Agent responses** - LangGraph results parsed into `AgentResponse` dataclass with typed fields
7. **Single entry point** - All routes in `api/index.py`
8. **Context caching** - Optimize AI costs with cached System Prompts and product catalog
9. **Atomic transactions** - Use PostgreSQL RPC for all transactional operations
10. **No ORM** - Direct SQL queries via supabase-py only

## 7. Documentation Reference

**⚠️ BEFORE making ANY changes, read `.cursor/rules/development-workflow.mdc`**

For detailed specifications, see `docs/`:
- `docs/Brief.md` - Business requirements
- `docs/ai-strategy.md` - RAG, Function Calling, Structured Outputs
- `docs/database-schema.md` - ERD, SQL Views, RPC functions
- `docs/api-specification.md` - Endpoints, contracts
- `docs/async-architecture.md` - QStash patterns, BackgroundTasks
- `docs/ON_DEMAND_ORDERS.md` - Order model
- `docs/sequence-diagrams.md` - Process flows
- `docs/QSTASH_EXPLAINED.md` - QStash usage

**Rule:** Rules provide quick patterns, Documentation provides complete context.
